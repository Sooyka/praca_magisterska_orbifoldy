% mainfile: ../praca_magisterska_orbifoldy.tex
\chapter{Algorithm for searching for the spectrum}

In the previous chapter we answeared the questions about how $\spe$ looks like -- in particular 
what is it's order type and topology. In this chapter we would like to develop a 
methods for answearing the 
following question: 
%In the previous chapter the main question was about which rational numbers are in $\spe$. 
%We can ask, how to answear the question 

%In this chapter we will show that the question 
"For a given rational number, is it in $\spe$?" 

We have some sort of answear to this question -- an algorithm.
%a very long equation that 
%commonly is refered to as an algorithm. 

It is not an ideal answear as it gives little insight of what is a general structure 
of the spectrum. Nethertheless it is a constructive and computable answear. 
%What's more, 
%later, in implementation chapter we discuss that for numbers with denominators of a reasonable 
%size and in reasonable distance from zero this algorithm can be run successfully on a 
%personal computer.

%is computable.

%In this chapter, we will provide the best answear we could find. 

%Turns aout that the number is in the specturm iff the following procedute says "yes". 

%It turns aout that the question for any number is answearable  

%Algorithmical approunch to questions from chapter 3 are only possible after gfiniteness 
%part of chapter four.

%What we can show, is that this question is computable -- i.e. there exists an algorithm 
%that answears this question. 

%Using results from previous chapters, we can now prove, that some computational problems related 
%to spectra are solvable.

%We will do it in a constructive way, by writing explicitly the algorithm and proving its
%correctness.

% and properties.

%We will also be able to actually compute sufficiently small examples of the 
%question.
%unansweared question 

The exact question we will provide algorithm to answear here is: 

\textit{For a given rational number $r$ and manifold $M$, is there at least one 
$M$ orbifold with $r$ as its \Eoc?}

%For a given rational number $r$ and manifold $M$:
%\begin{itemize}
%\item How many $M$ orbifolds with $r$ as their \Eoc\ are there?
%\item The accumulation point of what degree is $r$ in $\spe(M)$?
%\end{itemize}

We start with $r=\frac{p}{q}$, where $p \in \mathbb{Z}$, $q \in \mathbb{N}_{>0}$ and a manifold $M$. 
%\section{Reductions and special cases}

%\section{Decidability}
%\todo{oj dokończyć}
%Here we will show the proof that the problem of "deciding whether a given rational number is in an 
%Euler orbicharacteristic's spectrum or not" is decidable by showing algorithm for doing this. 
%Later, our algorithm will have a bonus property of determining of which order of condensation 
%is given point if it is in fact in $\sigma$. \\
%\smalltodoII{Może od razu postawić pełny problem}
%%It fill get also a performance enhancement by this added property. \\
%First stated algorithm is also very inefficient and is presented, because the idea is the most 
%clear in it. Right after it there is stated an algorithm with two enhancements: 
%\begin{itemize}
%\item determining an accumulation point of which order is a given point, if it is in fact in the 
%spectrum (this enhancement gives also a performance boost) 
%\item faster searching, because some cases do not need to be checked. 
%\end{itemize}
%\subsection{The algorithm}
%and $\textrm{gcd}(p,q)$. \\ 
\section{Reduction from arbitrary $M$ do $D^2$}
This reduction is based on \ref{spe_M}.
Note, that this is a different reduction than the one in \ref{reduction_to_arithmetical}. 
In \ref{reduction_to_arithmetical} we are saying that for any $M$, we have $\spebr{M} 
\subseteq \speS \cup \speD$. In \ref{spe_M} on the other hand we have, that 
for a manifold $M$ with $h$ handles, $c$ crosscaps and $b$ boundary components: \\
for $b \neq 0$:
\begin{equation}
\spe(M) = \speD - 2h - c - (b - 1)
\end{equation}
and for $b = 0$:
\begin{equation}
\spe(M) = 2\speD - 2h - c.
\end{equation}  


Using \ref{spe_M} 
%and \ref{} 
we conclude that the problem of deciding whether $\frac{p}{q}$ is in $\spe(M)$
is equivalent to deciding: \\
for $b \neq 0$ if:
\begin{equation}
\frac{p}{q} + 2h + c + (b-1) 
\end{equation} 
is in $\sdD$; \\
for $b = 0$ if:
\begin{equation}
\frac{1}{2}\frac{p}{q}+h+\frac{c}{2}
\end{equation}
is in $\sdD$.

Considering this fact, from this point, WLOG we will assume that $M = D^2$ and, 
following \ref{only dihedral}, we will 
be conserned only with dihedral orbipoints.

%\subsection{Arithmetic formulation}
%We want to determine whether there exists $d_1,d_2,\cdots,d_k$, such that 
%$\chi^{orb}(*d_1\cdots d_k) = \frac{p}{q}$. 

\section{Special cases}
In the case that $\frac{p}{q}$ is of the form $l\frac{1}{4}$, for some whole $l$ 
% $q = 4$ 
we can give the answer right away. For $l > 4$ we have that $l\frac{1}{4}$ is not in the set 
and for $l \leq 4$ it is (see \ref{greatest \apots}). 

Moreover for an even $l$ we have that $l\frac{1}{4}$ is a condensation point of order 
$\frac{4-l}{2}$ 
and for an odd $l$ it is a condensation point of order $\frac{3-l}{2}$ (see \ref{greatest \apots} 
and \ref{predescors}). 

In the case, where $\frac{p}{q} > 1$, we also can give answer rigth away and this answr is "no". 

Now we will consider only cases when $\frac{p}{q}$ is not of the form $l\frac{1}{4}$ and is 
$\leq 1$.
%\section{General case}
%
%\section{Simpler version of the question}
%
%To present the idea of searching the spectrum for the orbifolds with a given \Eoc, we will 
%first present the algorithm that answears a little easier question, namely: 
%
%\textit{For a given rational number $r$ and manifold $M$, is there at least one 
%$M$ orbifold with $r$ as their \Eoc?}
%
%This algorithm will mirror what we are focused on in \ref{chapter_three}, giving us the 
%computational tool for deciding whether a given number is in the spectrum or no. 
%
%The first approach of the searching algorithm is of this form: \\
%
%%We start with the 
%We use: 
%\begin{itemize}
%$\mathbb{N}$ counters $d_1d_2\cdots$ 
%(with values ranging from $1$, through all natural numbers, to infinity 
%(with infinity included)) set to $1$. Each counter correspond to one cone point 
%on the boundry of the disk of period equal to the value of the counter (with the note, that 
%if counter is set to $1$ it means a trivial cone point - namely a none cone point, a normal 
%point). 
%Every state of the counters during runtime of the algorith will have only finitely many 
%counters with value non-$1$. Moreover every state in the rutime of the algorithm 
%will have values on consequtive counters ordered in weakly decreasing order. From now we will 
%consider only such states. \\
%The state $d_1d_2\cdots$ correspond to the orbifold of 
%\Eoc equal $\chi^{orb}(*d_1d_2\cdots)$ (where the trailing $1$ are trunkated). \\ 
%%There is also a pivot pointing on one counter at any time.  
\section{Regular cases}
First we will describe what we use in the algorithm, giving the brief semantics. 
The detailed semantics are given in \ref{idea of the algorithm}.
\subsection{What we use}
We use: 
\begin{itemize}
\item $\mathbb{N}_{>0}$ counters $c_1, c_2, \cdots$ 
with values ranging on $\mathbb{N}_{>0}\cup\{\infty\}$.
%$1$, through all natural numbers, to infinity 
%(with infinity included). 
Each counter correspond to one dihedral point 
on the boundry of the disk of period equal to the value of the counter (with the note, that 
if counter is set to $1$ it means a trivial dihedral point - namely a non-orbi point, 
a normal point). 

We will write the state of the counters without commas, using the letter $d$. 
Note that with this convention, $c_i$ will refer to the $i$-th counter and $d_i$ will 
refet to the value of the $i$-th counter. 

So the state of the counters $d_1d_2\cdots$ correspond to the orbifold 
$*d_1d_2\cdots$ (where the trailing $1$'s are trunkated).

We will refer to the counters being "to the left" or "to the right" of each other, as 
the numbering would go from left to right.

\item a pivot pointing at some counter 
% at any time
\item a flag that can be set to: "Greater", "Searching" or "Less" corresponding to what was 
the outcome of comparing \Eoc\ of the orbifold corresponding to counters' state and 
$\frac{p}{q}$ or to the fact, that there is a need for a search of the next state of counters 
to compare with $\frac{p}{q}$.  
\end{itemize}
\subsection{What state are we starting our algorithm with}
We start with:
\begin{itemize}
\item all counters set to $1$. 
\item pivot pointing at the $c_1$
\item flag set to "Greater"
\end{itemize}
%If $\frac{p}{q}$ is of form $\frac{k}{4}$, where $k \in (-\infty,8] \cap \mathbb{Z}$ we give 
%the answear "yes" and end the whole algorithm. If $\frac{p}{q} > 2$ we give the answear "no" and 
%end the whole algorithmBecauseof this, below we assume, that \\
\subsection{Invariants claims}
Now we will state the claims of what properties the state of the counters will maintain 
during all the execution of the algorithm. The proof, that this is indeed the case will 
be performed in 
\ref{memory state proof}
\begin{claim}\label{valid state of counters}
We will do our computation such that:
\begin{itemize}
\item every state of the counters during runtime of the algorithm will have only finitely many 
counters with value non-$1$. 
\item every state in the rutime of the algorithm 
will have values on consequtive counters ordered in weakly decreasing order.
\end{itemize}
\end{claim}
From now we will 
consider only such states. 

%There is also a pivot pointing on one counter at any time.  
%The state of the counters $d_1d_2\cdots$ correspond to the orbifold 
%%of \Eoc\ equal $\chi^{orb}(*d_1d_2\cdots)$
%$*d_1d_2\cdots$ (where the trailing $1$'s are trunkated). 
\subsection{The algorithem for searching for a spectrum}
When the algorithm is in the state: 
\begin{itemize}
\item counters with values: $d_1d_2\cdots$
\item pivot: at the counter $c_p$
\item flag: set to the value $flag\_value$,
\end{itemize}
we procced as follows 
%(the term "We continue." means, that we start the following procedure from the beginning)
:
%// More on how we search for it will be told later, 
%        // for now we can think that we search one by one,
%        // starting from $d_p$ and going up till $d_p'$.
\begin{lstlisting}[firstnumber=1,consecutivenumbers=true]
In the case, the $flag\_value$ is equal to: 
{
    "Greater", then
    {
        If $\chi^{orb}(*d_1\cdots d_{p-1}\infty d_{p+1}\cdots)=\frac{p}{q}$ then
        {
            We found an orbifold and we are ending the whole
            algorithm with answer "yes, $*d_1\cdots d_{p-1}\infty d_{p+1}\cdots$".
            
            
            
        } 
        If $\chi^{orb}(*d_1\cdots d_{p-1}\infty d_{p+1}\cdots)>\frac{p}{q}$ then
        {
            We set $d_p$ to $\infty$.
            We set the flag to "Greater".
            We put the pivot at the $c_{p+1}$.
            We go to the 1st line.
        }  
        If $\chi^{orb}(*d_1\cdots d_{p-1}\infty d_{p+1}\cdots)<\frac{p}{q}$ then
        {
            We set the flag to "Searching".
            We go to the 1st line.
        }  
    }
    
    "Searching", then
    {
        We search one by one 
        for the value $d_p'$ of the $c_p$ such that
        $\chi^{orb}(*d_1\cdots d_{p-1}d_p'd_{p+1}\cdots)\leq\frac{p}{q}$ and
        $\chi^{orb}(*d_1\cdots d_{p-1}(d_p'-1)d_{p+1}\cdots)>\frac{p}{q}$.
        if $\chi^{orb}(*d_1\cdots d_{p-1}d_p'd_{p+1}\cdots)=\frac{p}{q}$ then 
        {
            We found an orbifold and we are ending the whole
            algorithm with answer "yes, $*d_1\cdots d_{p-1}d_p'd_{p+1}\cdots$".
            
            
        }
        We set $d_p$ and values of all the counters 
        to the left of $c_p$ to the value $d_p'$.
        if $\chi^{orb}(*d_1d_2d_3\cdots)=\frac{p}{q}$ then 
        {
            We found an orbifold and we are ending the whole
            algorithm with answer "yes, $*d_1d_2\cdots$".
            
            
            
        }
        If $\chi^{orb}(*d_1d_2d_3\cdots)<\frac{p}{q}$ then 
        {
            We set the flag to "Less".
            We put the pivot at the $c_{p+1}$.
            We go to the 1st line.
        }
        If $\chi^{orb}(*d_1d_2d_3\cdots)>\frac{p}{q}$ then 
        {
            We set the flag to "Greater".
            We put the pivot at the $c_1$.
            We go to the 1st line.
        }
    }
    
    "Less", then 
    {
        If $d_p = 1$ and the values of all the counters 
        on the left of $c_p$ are equal to 2 then 
        {
            We end the whole algorithm with the answer "no".
        }
        We increase $c_p$ by one ($d_p \coloneqq d_p + 1$) and
        we set the value of all counters on the left of $c_p$ to $d_p$.
        If $\chi^{orb}(*d_1d_2d_3\cdots)=\frac{p}{q}$ then
        {
            We found an orbifold and we are ending the whole
            algorithm with answer "yes, $*d_1d_2\cdots$".
            
            
            
        }
        If $\chi^{orb}(*d_1d_2d_3\cdots)>\frac{p}{q}$ then  
        {
            We set the flag to "Greater".
            We put the pivot at the $c_1$. 
            We go to the 1st line.
        } 
        If $\chi^{orb}(*d_1d_2d_3\cdots)<\frac{p}{q}$ then
        {
            We set the flag to "Less".
            We put the pivot at the $c_{p+1}$.
            We go to the 1st line.
        } 
    }
}
\end{lstlisting}
\section{The idea of the algorithm}\label{the idea of the algorithm}
We will now present in more detail what the algorithm is intented to do. 
To do this and for the later sections, we will introduce an order on the states 
of counters satisfying \ref{valid state of counters} (as mentioned in 
\ref{valid state of counters} we will consider only such states): 
\begin{definition}
We define a linear order $\preceq$ on the states of counters as follows:

Let $D_1$ be a state of counters equal to $d_1^1d_2^1\cdots$ and $D_2$ be a state of counters 
equal to $d_1^2d_2^2\cdots$. Let $i$ be the greatest index where $D_1$ and $D_2$ differ, then:\\
$bullet$ If $d_i^1 \leq d_i^2$ then $D_1 \preceq D_2$. 
\end{definition}

This is a suborder of the lexicographical order 
of states of counters after truncation of trailing 1's 
with the counters to the right being more significant. 

\begin{observation}
In general it is not true that if $D_1 \preceq D_2$ then 
$\cho{*D_1} \leq \cho{*D_2}$ nor that if $D_1 \preceq D_2$ then 
$\cho{*D_1} \geq \cho{*D_2}$.
\end{observation}

\begin{observation}\label{good lexicographical order}
Since $\preceq$ is a suborder of a lexicographical order it is a good order. 
\end{observation}

We can explicitly write the form of the successor of any state $d_1d_2d_3\cdots$ in $\preceq$:
%(Quotation marks around the counters' states in the following 
%lemma are added here only for readability 
%and they bare no particular meaning.)
\begin{observation}\label{form of the successor}
The successor of 
the state $d_1d_2d_3\cdots$, of the form
\begin{equation}
\underbrace{\infty\infty\cdots\infty}_{k-1 \rm\ times} d_kd_{k+1}d_{k+2}\cdots,
\end{equation}
where $k$ is 
such that $c_k$ is the first counter 
from the left that is not set to $\infty$,
% in the state $d_1d_2d_3\cdots$, 
is
\begin{equation} 
\underbrace{(d_k+1)(d_k+1)\cdots(d_k+1)}_{k-1\rm\ times}(d_k+1)d_{k+1}d_{k+2}\cdots,
\end{equation}

\end{observation}
%\textbf{Proof.}
\begin{definition}
We will call the state $d_1d_2d_3\cdots$, such that no $d_k$ is equal to $\infty$ a 
\textbf{finite} state. 

We will call the state $d_1d_2d_3\cdots$, such that at least one of $d_k$ is equal to $\infty$ 
an \textbf{infinite} state.  
\end{definition}
\begin{observation}
Using \ref{valid state of counters} we have that 
for the state $d_1d_2d_3\cdots$ to be finite (resp. infinite), it is equivalent to 
$d_1$ being different from (resp. being equal to) $\infty$. 
\end{observation}
%\begin{observation}

%\end{observation}
\begin{observation}
For any state $D$, the successor of $D$ is a finite state.
\end{observation}
\begin{definition}
We will call the ascending sequence $\{D_n\}$ 
in $\preceq$, such 
that for all $n$, we have that $D_{n+1}$ is the succesor of $D_n$, a connected sequence in 
$\preceq$.   
\end{definition}

\begin{observation}\label{Successor lemma}
Let $D_1$ and $D_2$ be finite states and let $D_2$ be the successor of $D_1$ in 
$\preceq$. Then $\cho{*D_1} > \cho{*D_2}$.
\end{observation}
\textbf{Proof.}
From \ref{form of the successor} we know, that taking the successor 
of the finite state always chages  
only first counter and it is changing it by increasing it by 1. 
Increasing the order of the orbipoint  
decreases \Eoc. $_\square$

\begin{corollary}\label{connected sequences corollary}
The sequence $\{\cho{*D_n}\}$ is descending for every connected sequence 
of finite states $\{D_n\}$ in $\preceq$. 
\end{corollary}
\begin{lemma}\label{chi supp functoriality}
Let $d_1$ be different form $\infty$. 
The supremum of the connected sequence $\{(d_1+n)d_2d_3\cdots\}$ is $\infty d_2d_3\cdots$, and 
%the following diagram commutes:
the infimum of the corresponding sequence $\{\chi(*(d_1+n)d_2d_3\cdots)\}$ is  
$\chi(*\infty d_2d_3\cdots)$.
\end{lemma}
\textbf{Proof.} 
%From \ref{good lexicographical order} we know, that every bounded sequence in $\preceq$ have 
%sup

For every $n$ we have that $(d_1+n)d_2d_3\cdots\preceq\infty d_2d_3\cdots$. Furthermore for 
every $d_1'd_2'd_3'\cdots$ suck that $d_1'd_2'd_3'\cdots\preceq \infty d_2d_3\cdots$, there 
exists $n$, such that $d_1'd_2'd_3' \cdots\preceq(d_1+n)d_2d_3\cdots$. Thus, $\infty d_2d_3\cdots$ 
is the supremum of $\{(d_1+n)d_2d_3\cdots\}$.

For every $n$ we have that: 
\begin{align}
\chi(*(d_1+n)d_2d_3\cdots) &= \chi(*d_1d_2d_3\cdots) 
- \frac{(d_1+n)-1}{2(d_1+n)} + \frac{d_1-1}{2d_1} \notag\\ 
&= \chi(*d_1d_2d_3\cdots) - \frac{1}{2d_1} + \frac{1}{2(d_1+n)}
\end{align}
We also have that:
\begin{align}
\chi(*\infty d_2d_3\cdots) &= \chi(*d_1d_2d_3\cdots) 
- \frac{1}{2} + \frac{d_1-1}{2d_1} \notag\\ 
&= \chi(*d_1d_2d_3\cdots) - \frac{1}{2d_1} + 0.
\end{align}
Thus $\chi(*\infty d_2d_3\cdots)$ is the infimum of $\{\chi(*(d_1+n)d_2d_3\cdots)\}$.
$_\square$

\begin{lemma}
The state of the counters in the algorithm is weakly increasing with respect to order $\preceq$. 
\end{lemma}
\textbf{Proof.} \\
The state of the counters is changed in lines 10-11, 46, 66-67. In each of these lines 
the counter with the gretest index of all changed counters increases in value, so 
the resulting state is bigger with respect to order $\preceq$. $_\square$

\subsection{Basic idea}
The basic idea of the algorithm is to search through all the states of the counters going 
from the smallest (in the sense of $\preceq$) state of counters, which will be when all counters 
are set to $1$, up to some upper limit beyond which we are sure that no configuration of 
counters will yield the \Eoc\ that we are looking for. 

Now we will go through several obstacles of how to do so and solutions for them, answearing for 
example the 
questions how we go through all the states and what can be this upper limit. 

%More on the upper limit will be addre

%However this can't be done directly as there are infinite ascending sequences in $\preceq$. 
\subsection{Checking all the states}
This can't be done directly as there are infinite ascending sequences in $\preceq$. 

%However, by \ref{Successor lemma} we know, that for every ascending sequence $\{a_n\}$ 
%in $\preceq$, such 
%that for all $n$, we have that $a_{n+1}$ is the succesor of $a_n$, we have that the sequence 
%$\{\cho{*a_n}\}$ is strictly descending. 

However, thanks to \ref{connected sequences corollary}, 
when we are searching through the infinite connected sequence in 
$\preceq$, once we get to the state $D_n$ for which $\cho{*D_n} < \frac{p}{q}$, we now 
that no state $D_m$ with $m>n$ can have $\cho{*D_m} = \frac{p}{q}$ 
and we can disregard whole sequence. 

There is, however, another problem, namely, that when we are searching through 
the infinite connected sequence, 
%of consequtive 
%states of counters, 
initialy, we don't now, whether there will be any state 
$D = d_1d_2d_3\cdots$ in it, that 
will have $\cho{*d_1d_2d_3\cdots} \leq \frac{p}{q}$. 
However, thanks to \ref{chi supp functoriality} 
we can check for this, by first comparing $\frac{p}{q}$ with 

\subsection{Three "modes" of the algorithm}
The algorithm has three distinct fragments: 
\begin{itemize}
\item fragment in the lines 3-35. that will be called the "Greater" part,
\item fragment in the lines 27-62, that will be called the "Searching" part,
\item fragment in the lines 64-93, that will be called the "Less" part.
\end{itemize}
%The graph of the control flow of these parts looks like this:


\section{Proof of the correctness of the algorithm}
Firstly, let us observe, that algorithm gives the answear on lines 8, 14-15, 35-36, 55-56, 
62-63 and 
always ends immedietly after giving the answear. Thus, it will always give at most one answear.
Furthermore let us observe that these are the only places where the algorithm terminates, 
so if it terminates it will give at least one answear.
 
There are three things to be checked: \\
$\bullet$ That the algorithm never answears "yes" if there is no orbifold of the \Eoc\ 
$\frac{p}{q}$ (No false positives)\\
$\bullet$ That the algorithm never answears "no" if there is an orbifold of \Eoc\ 
$\frac{p}{q}$ (No false negatives)\\ 
$\bullet$ That the algorithm always ends in a finite number of steps (Guaranteed termination). 

%To do this, we will introduce an order on the states of counters satisfying 
%\ref{valid state of counters}:



%\begin{lemma}

%\end{lemma}
%\textbf{Proof.} \\

%\begin{lemma}

%\end{lemma}
%\textbf{Proof.} \\

\subsection{No false positives}
Algorithm gives answear "yes" at lines 7-8, 35-36, 44-45, 75-76. At each of these places, 
the answear contains the example of an orbifold with \Eoc\ equal to $\frac{p}{q}$ that was 
explicitly checked for correctness just before giving the answear (see lines 5, 33, 42, 73). 
$_\square$    
\subsection{No false negatives}
Let $\cho{*d_1d_2\cdots} = \frac{p}{q}$. 

%Let us assume for a contradiction, that algorithm started with $\frac{p}{q}$ answered "no". 
%
%We will show that this is impossible, by showing, that the algorithm will never 
%go beyond $d_1d_2\cdots$ in $\preceq$ order. 

We will show that the algorithm will never 
go beyond $d_1d_2\cdots$ counter state in $\preceq$ order. 

Let us observe that the only lines where 
the counters are changed are lines 15, 40-41 and 71-72, and while changing, 
only counters 
at pivot and to the left of the pivot are changed. 

Because of that, going beyond $d_1d_2\cdots$ counter state 
could happen only in lines 10-11, 40 or 58-59, while pivot would be 
%lovely
on the rightmost counter that is differrent from $d_1d_2\cdots$. 
%This is because these are the only lines where the counters are changed and while changing, 
%only counters 
%at pivot and to the left of the pivot are changed. 

We will now eliminate all three options case by case. 
\subsubsection{Line 15}
\subsubsection{Lines 40-41}
\subsubsection{Lines 71-72}

\subsection{Guaranteed termination}

%\begin{enumerate}
%    \item if the pivot is on the zeroth column ($c = 0$), then 
%    \begin{enumerate}[label*=\arabic*.]
%        \item 
%        \item
%    \end{enumerate}
%    \item abcd
%\end{enumerate}
%\section{Improvements}

\section{Another questions the algorithm can answear}
\subsection{Deciding the order of accumulation}
Let $m \in \mathbb{N}$ be such that $\frac{p}{q} \in (1-\frac{m}{2},1-
\frac{m+1}{2})$
Let us denote by $r \coloneqq \frac{p}{q} - (1-\frac{m}{2})$. \\ 

We will searching in $\sigma$ as such: \\

If $\frac{p}{q} \in \sigma$, then, from the corollary \ref{predescors} we know, that there 
exist some $n \in \mathbb{N}$, such that $\frac{p}{q} + \frac{n}{2} \in \sigma$ but 
$\frac{p}{q} + \frac{n}{2} \not\in \sigma$. \\

We will be consequently checking points from $1+r$, through $1+r-\frac{l}{2}$, for 
$0 \leq l \leq m$, to the $\frac{p}{q}$. We stop at the first found point. 
If one of these point is in the spectrum, then all smaller (so also $\frac{p}{q}$) are in 
the spectrum and $\frac{p}{q}$ is the accumulation point of the spectrum of order $m-l$ 
(from this, 
we can see some heuristic, that the points that have smaller order will be generally 
harder to find in some sense). If none of this points are in in the spectrum, then $\frac{p}{q}$ 
is not. \\

\section{Implementation}
This algorithm is a part of the algorithm from \ref{Counting orbifolds -- arithmetical part} 
where the implementation of the whole will be discused in \ref{implementation}.
