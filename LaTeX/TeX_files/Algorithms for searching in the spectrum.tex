% mainfile: ../praca_magisterska_orbifoldy.tex
\chapter{Algorithms for searching in the spectrum}

In the previous chapter we answeared the questions about how $\spe$ looks like -- in particular 
what is it's order type and topology. In this chapter we would like to develop a 
methods for answearing the 
following question: 
%In the previous chapter the main question was about which rational numbers are in $\spe$. 
%We can ask, how to answear the question 

%In this chapter we will show that the question 
"For a given rational number, is it in $\spe$?" 
%is computable.

%In this chapter, we will provide the best answear we could find. 

%Turns aout that the number is in the specturm iff the following procedute says "yes". 

%It turns aout that the question for any number is answearable  

%Algorithmical approunch to questions from chapter 3 are only possible after gfiniteness 
%part of chapter four.

What we can show, is that this question is computable -- i.e. there exists an algorithm 
that answears this question. 
%Using results from previous chapters, we can now prove, that some computational problems related 
%to spectra are solvable.
We will do it in a constructive way, by writing explicitly the algorithm and proving its
correctness.
% and properties.

%We will also be able to actually compute sufficiently small examples of the 
%question.
%unansweared question 

The exact question we will provide algorithm to answear here is: 

\textit{For a given rational number $r$ and manifold $M$, is there at least one 
$M$ orbifold with $r$ as its \Eoc?}

%For a given rational number $r$ and manifold $M$:
%\begin{itemize}
%\item How many $M$ orbifolds with $r$ as their \Eoc\ are there?
%\item The accumulation point of what degree is $r$ in $\spe(M)$?
%\end{itemize}

We start with $r=\frac{p}{q}$, where $p \in \mathbb{Z}$, $q \in \mathbb{N}_{>0}$ and a manifold $M$. 
%\section{Reductions and special cases}

%\section{Decidability}
%\todo{oj dokończyć}
%Here we will show the proof that the problem of "deciding whether a given rational number is in an 
%Euler orbicharacteristic's spectrum or not" is decidable by showing algorithm for doing this. 
%Later, our algorithm will have a bonus property of determining of which order of condensation 
%is given point if it is in fact in $\sigma$. \\
%\smalltodoII{Może od razu postawić pełny problem}
%%It fill get also a performance enhancement by this added property. \\
%First stated algorithm is also very inefficient and is presented, because the idea is the most 
%clear in it. Right after it there is stated an algorithm with two enhancements: 
%\begin{itemize}
%\item determining an accumulation point of which order is a given point, if it is in fact in the 
%spectrum (this enhancement gives also a performance boost) 
%\item faster searching, because some cases do not need to be checked. 
%\end{itemize}
%\subsection{The algorithm}
%and $\textrm{gcd}(p,q)$. \\ 
\section{Reduction from arbitrary $M$ do $D^2$}
This reduction is based on \ref{spe_M}.
Note, that this is a different reduction than the one in \ref{reduction_to_arithmetical}. 
In \ref{reduction_to_arithmetical} we are saying that for any $M$, we have $\spebr{M} 
\subseteq \speS \cup \speD$. In \ref{spe_M} on the other hand we have, that 
for a manifold $M$ with $h$ handles, $c$ crosscaps and $b$ boundary components: \\
for $b \neq 0$:
\begin{equation}
\spe(M) = \speD - 2h - c - (b - 1)
\end{equation}
and for $b = 0$:
\begin{equation}
\spe(M) = 2\speD - 2h - c.
\end{equation}  


Using \ref{spe_M} 
%and \ref{} 
we conclude that the problem of deciding whether $\frac{p}{q}$ is in $\spe(M)$
is equivalent to deciding: \\
for $b \neq 0$ if:
\begin{equation}
\frac{p}{q} + 2h + c + (b-1) 
\end{equation} 
is in $\sdD$; \\
for $b = 0$ if:
\begin{equation}
\frac{1}{2}\frac{p}{q}+h+\frac{c}{2}
\end{equation}
is in $\sdD$.

Considering this fact, from this point, WLOG we will assume that $M = D^2$ and, 
following \ref{only dihedral}, we will 
be conserned only with dihedral orbipoints.

%\subsection{Arithmetic formulation}
%We want to determine whether there exists $d_1,d_2,\cdots,d_k$, such that 
%$\chi^{orb}(*d_1\dots d_k) = \frac{p}{q}$. 

\section{Special cases}
In the case that $\frac{p}{q}$ is of the form $l\frac{1}{4}$, for some whole $l$ 
% $q = 4$ 
we can give the answer right away. For $l > 4$ we have that $l\frac{1}{4}$ is not in the set 
and for $l \leq 4$ it is (see \ref{greatest \apots}). 

Moreover for an even $l$ we have that $l\frac{1}{4}$ is a condensation point of order 
$\frac{4-l}{2}$ 
and for an odd $l$ it is a condensation point of order $\frac{3-l}{2}$ (see \ref{greatest \apots} 
and \ref{predescors}). 

In the case, where $\frac{p}{q} > 1$, we also can give answer rigth away and this answr is "no". 

Now we will consider only cases when $\frac{p}{q}$ is not of the form $l\frac{1}{4}$ and is 
$\leq 1$.
%\section{General case}
%
%\section{Simpler version of the question}
%
%To present the idea of searching the spectrum for the orbifolds with a given \Eoc, we will 
%first present the algorithm that answears a little easier question, namely: 
%
%\textit{For a given rational number $r$ and manifold $M$, is there at least one 
%$M$ orbifold with $r$ as their \Eoc?}
%
%This algorithm will mirror what we are focused on in \ref{chapter_three}, giving us the 
%computational tool for deciding whether a given number is in the spectrum or no. 
%
%The first approach of the searching algorithm is of this form: \\
%
%%We start with the 
%We use: 
%\begin{itemize}
%$\mathbb{N}$ counters $d_1d_2\dots$ 
%(with values ranging from $1$, through all natural numbers, to infinity 
%(with infinity included)) set to $1$. Each counter correspond to one cone point 
%on the boundry of the disk of period equal to the value of the counter (with the note, that 
%if counter is set to $1$ it means a trivial cone point - namely a none cone point, a normal 
point). 
%Every state of the counters during runtime of the algorith will have only finitely many 
%counters with value non-$1$. Moreover every state in the rutime of the algorithm 
%will have values on consequtive counters ordered in weakly decreasing order. From now we will 
%consider only such states. \\
%The state $d_1d_2\dots$ correspond to the orbifold of 
%\Eoc equal $\chi^{orb}(*d_1d_2\dots)$ (where the trailing $1$ are trunkated). \\ 
%%There is also a pivot pointing on one counter at any time.  
\section{Regular cases}
We use: 
\begin{itemize}
\item $\mathbb{N}_{>0}$ counters $c_1, c_2, \dots$ 
with values ranging on $\mathbb{N}_{>0}\cup\{\infty\}$.
%$1$, through all natural numbers, to infinity 
%(with infinity included). 
Each counter correspond to one dihedral point 
on the boundry of the disk of period equal to the value of the counter (with the note, that 
if counter is set to $1$ it means a trivial dihedral point - namely a non-orbi point, 
a normal point). 

We will write the state of the counters without commas, using the letter $d$. 
Note that with this convention, $c_i$ will refer to the $i$-th counter and $d_i$ will 
refet to the value of the $i$-th counter. 

We will refer to the counters being "to the left" or "to the right" of each other, as 
the numbering would go from left to right.

\item a pivot pointing at some counter 
% at any time
\item a flag that can be set to "Greater" or "Less" corresponding to what was 
the outcome of comparing \Eoc\ of the orbifold corresponding to counters' state and 
$\frac{p}{q}$.  
\end{itemize}

We start with:
\begin{itemize}
\item all counters set to $1$. 
\item pivot pointing at the $c_1$
\item flag set to "Greater"
\end{itemize}
%If $\frac{p}{q}$ is of form $\frac{k}{4}$, where $k \in (-\infty,8] \cap \mathbb{Z}$ we give 
%the answear "yes" and end the whole algorithm. If $\frac{p}{q} > 2$ we give the answear "no" and 
%end the whole algorithmBecauseof this, below we assume, that \\

\begin{claim}\label{valid state of counters}
We will do our computation such that:
\begin{itemize}
\item every state of the counters during runtime of the algorithm will have only finitely many 
counters with value non-$1$. 
\item every state in the rutime of the algorithm 
will have values on consequtive counters ordered in weakly decreasing order.
\end{itemize}
\end{claim}
From now we will 
consider only such states. 

%There is also a pivot pointing on one counter at any time.  
The state of the counters $d_1d_2\dots$ correspond to the orbifold 
%of \Eoc\ equal $\chi^{orb}(*d_1d_2\dots)$
$*d_1d_2\dots$ (where the trailing $1$'s are trunkated). 

When the algorithm is in the state: 
\begin{itemize}
\item counters with values: $d_1d_2\dots$
\item pivot: at the counter $c_p$
\item flag: set to the value $flag\_value$,
\end{itemize}
we procced as follows 
%(the term "We continue." means, that we start the following procedure from the beginning)
:
\begin{lstlisting}[firstnumber=1,consecutivenumbers=true]
In the case, the flag is set to: 
{
    "Less", then 
    {
        If $d_p = 1$ and the values of all the counters 
        on the left of $c_p$ are equal to 2 then 
        {
            We end the whole algorithm with the answer "no".
        }
        We increase $c_p$ by one ($d_p \coloneqq d_p + 1$) and
        we set the value of all counters on the left of $c_p$ to $d_p$.
        If $\chi^{orb}(*d_1d_2\dots)=\frac{p}{q}$ then
        {
            We found an orbifold and we are ending the whole
            algorithm with answer "yes, $*d_1d_2\dots$".
        }
        If $\chi^{orb}(*d_1d_2d_3\dots)>\frac{p}{q}$ then  
        {
            We set the flag to "Greater".
            We put the pivot on the $c_1$. 
            We go to the 1st line.
        } 
        If $\chi^{orb}(*d_1d_2d_3\dots)<\frac{p}{q}$ then
        {
            We set the flag to "Less".
            We put pivot on the $c_{p+1}$.
            We go to the 1sts line.
        } 
    }

    "Greater", then
    {
        If $\chi^{orb}(*d_1\dots d_{p-1}\infty d_{p+1}\dots)=\frac{p}{q}$ then
        {
            We found an orbifold and we are ending the whole
            algorithm with answer "yes, $*d_1\dots d_{p-1}\infty d_{p+1}\dots$".
        } 
        If $\chi^{orb}(*d_1\dots d_{p-1}\infty d_{p+1}\dots)>\frac{p}{q}$ then
        {
            We set $d_p$ to $\infty$.
            We set the flag to "Greater".
            We move pivot on the $c_{p+1}$.
            We go to the 1st line.
        }  
        If $\chi^{orb}(*d_1\dots d_{p-1}\infty d_{p+1}\dots)<\frac{p}{q}$ then
        {
            We search for value $d_p'$ of the $c_p$ 
            such that $\chi^{orb}(*d_1\dots d_{p-1}d_p'd_{p+1}\dots)\leq\frac{p}{q}$ 
            and $\chi^{orb}(*d_1\dots d_{p-1}(d_p'-1)d_{p+1}\dots)>\frac{p}{q}$.
            // More on how we search for it will be told later, 
            // for now we can think that we search one by one,
            // starting from $d_p$ and going up till $d_p'$.
            if $\chi^{orb}(*d_1\dots d_{p-1}d_p'd_{p+1}\dots)=\frac{p}{q}$ then 
            {
                We found an orbifold and we are ending the whole
                algorithm with answer "yes, $*d_1\dots d_{p-1}d_p'd_{p+1}\dots$".
            }
            We set $d_p$ and  values of all the counters 
            to the left of $c_p$ to the value $d_p'$.
            if $\chi^{orb}(*d_1d_2d_3\dots)=\frac{p}{q}$ then 
            {
                We found an orbifold and we are ending the whole
                algorithm with answer "yes, $*d_1d_2\dots$".
            }
            If $\chi^{orb}(*d_1d_2d_3\dots)<\frac{p}{q}$ then 
            {
                We set flag to "Less".
                We move the pivot to the column $c+1$.
                We go to the 1st line.
            }
            If $\chi^{orb}(*d_1d_2d_3\dots)>\frac{p}{q}$ then 
            {
                We set the flag to "Greater".
                We move the pivot to the $c_1$.
                We go to the 1st line.
            }
        }  
    }
}
\end{lstlisting}
\section{The idea of the algorithm}
We will now present in more detail what the algorithm is intented to do. 
To do this and for the later sections, we will introduce an order on the states 
of counters satisfying \ref{valid state of counters}: 
\begin{definition}
We define a linear order $\preceq$ on the states of counters as follows:

Let $C^1$ be a state of counters equal to $d_1^1d_2^1\dots$ and $C^2$ be a state of counters 
equal to $d_1^2d_2^2\dots$. Let $i$ be the greatest index where $C^1$ and $C^2$ differ, then:\\
$bullet$ If $d_i^1 \leq d_i^2$ then $C^1 \preceq C^2$. 
\end{definition}

This is a lexicographical order 
of states of counters after truncation of trailing 1's 
with the counters to the right being more significant. 

\begin{observation}
In general it is NOT true that if $C^1 \preceq C^2$ then 
$\cho{*C^1} \leq \cho{*C^2}$.
\end{observation}

\begin{observation}
Since $\preceq$ is a lexicographical order it is a good order. 
\end{observation}

\begin{observation}
Let $C^2$ be the successor of $C^1$ in $\preceq$. Then $\cho{*C^1} \leq \cho{*C^2}$.
\end{observation}
\textbf{Proof.}


\begin{lemma}
The state of the counters in the algorithm is weakly increasing with respect to order $\preceq$. 
\end{lemma}
\textbf{Proof.} \\
The state of the counters is changed in lines 10-11, 40, 58-59. In each of these lines 
the counter with the gretest index of all changed counters increases in value, so 
the resulting state is bigger with respect to order $\preceq$. $_\square$

\subsection{}
The algorithm is 

However this can't be done directly as there are infinite ascending sequences in $\preceq$. 
\subsection{}
 
\section{Why this works}
Firstly, let us observe, that algorithm gives the answear on lines 8, 14-15, 35-36, 55-56, 
62-63 and 
always ends immedietly after giving the answear. Thus, it will always give at most one answear.
Furthermore let us observe that these are the only places where the algorithm terminates.
 
There are three things to be checked: \\
$\bullet$ That the algorithm never answears "yes" if there is no orbifold of the \Eoc\ 
$\frac{p}{q}$ (No false positives)\\
$\bullet$ That the algorithm never answears "no" if there is an orbifold of \Eoc\ 
$\frac{p}{q}$ (No false negatives)\\ 
$\bullet$ That the algorithm always ends in a finite number of steps (Guaranteed termination). 

%To do this, we will introduce an order on the states of counters satisfying 
%\ref{valid state of counters}:



\begin{lemma}

\end{lemma}
\textbf{Proof.} \\

\begin{lemma}

\end{lemma}
\textbf{Proof.} \\

\subsection{No false positives}
Algorithm gives answear "yes" at lines 14, 35, 55, 62. At each of these places, 
the answear contains the example of an orbifold with \Eoc\ equal to $\frac{p}{q}$ that was 
explicitly checked for correctness just before giving the answear (see lines 12, 33, 53, 60).     
\subsection{No false negatives}
Let $\cho{*d_1d_2\dots} = \frac{p}{q}$. 

%Let us assume for a contradiction, that algorithm started with $\frac{p}{q}$ answered "no". 
%
%We will show that this is impossible, by showing, that the algorithm will never 
%go beyond $d_1d_2\dots$ in $\preceq$ order. 

We will show that the algorithm will never 
go beyond $d_1d_2\dots$ counter state in $\preceq$ order. 

Going beyond $d_1d_2\dots$ counter state 
could happen only in lines 10-11, 40 or 58-59, while pivot would be 
%lovely
on the rightmost counter that is differrent from $d_1d_2\dots$. 
This is because these are the only lines where the counters are changed and while changing, 
only counters 
at pivot and to the left of the pivot are changed. 

We will now eliminate all three options case by case. 
\subsubsection{}
\subsubsection{}
\subsubsection{}

\subsection{Guaranteed termination}

%\begin{enumerate}
%    \item if the pivot is on the zeroth column ($c = 0$), then 
%    \begin{enumerate}[label*=\arabic*.]
%        \item 
%        \item
%    \end{enumerate}
%    \item abcd
%\end{enumerate}
%\section{Improvements}


