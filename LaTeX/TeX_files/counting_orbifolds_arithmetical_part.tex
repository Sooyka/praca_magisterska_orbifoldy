% mainfile: ../praca_magisterska_orbifoldy.tex
\chapter{Counting orbifolds -- arithmetical part}\label{Counting orbifolds -- arithmetical part}


%\section{Arithmetical part}

%We want to determine this $n$. If $n = 0$, then $\frac{p}{q}$ is not in $\sigma$. 
%If $n > 0$, then $$
%\subsection{Deciding number of occurences}
%Searching for all occurences 

%The difficulty here is to carefully step other an occurence. 

%Compared to the previous version, we also use an occurance counter, starting with it set to 0 
%and with the list of orbifolds, wich is empty at the start.
\section{The idea of the algorithm}
This is an extention of the algorithm from \ref{}. It only differs by 
lines after finding the solution. Then, instead terminating it appends the sollution to the 
initialy empty list and proceeds to search through the states as if the solution was 
the starting configuration. 

\begin{lstlisting}[firstnumber=1,consecutivenumbers=true]
In the case, the $flag\_value$ is equal to: 
{
    "Greater", then
    {
        If $\chi^{orb}(*d_1\dots d_{p-1}\infty d_{p+1}\dots)=\frac{p}{q}$ then
        {
            We found an orbifold, we add it to a list 
            and increase the occurence counter by 1. 
            We set the flag to "Less".
            We put pivot to the $c_{p+1}$ counter.
            We go to the 1st line.
        } 
        If $\chi^{orb}(*d_1\dots d_{p-1}\infty d_{p+1}\dots)>\frac{p}{q}$ then
        {
            We set $d_p$ to $\infty$.
            We set the flag to "Greater".
            We put the pivot at the $c_{p+1}$.
            We go to the 1st line.
        }  
        If $\chi^{orb}(*d_1\dots d_{p-1}\infty d_{p+1}\dots)<\frac{p}{q}$ then
        {
            We set the flag to "Searching".
            We go to the 1st line.
        }  
    }
    
    "Searching", then
    {
        We search one by one 
        for the value $d_p'$ of the $c_p$ such that 
        $\chi^{orb}(*d_1\dots d_{p-1}d_p'd_{p+1}\dots)\leq\frac{p}{q}$ and 
        $\chi^{orb}(*d_1\dots d_{p-1}(d_p'-1)d_{p+1}\dots)>\frac{p}{q}$.
        We set $c_p$ and all of the counters 
        to the left of $c_p$ to the value $d_p'$.
        if $\chi^{orb}(*d_1d_2d_3\dots)=\frac{p}{q}$ then 
        {
            We found an orbifold, we add it to a list 
            and increase the occurence counter by 1. 
            We set the flag to "Less".
            We put the pivot at the $c_{p+1}$.
            We go to the 1st line.
        }
        If $\chi^{orb}(*d_1d_2d_3\dots)<\frac{p}{q}$ then 
        {
            We set the flag to "Less".
            We put the pivot at the $c_{p+1}$.
            We go to the 1st line.
        }
        If $\chi^{orb}(*d_1d_2d_3\dots)>\frac{p}{q}$ then 
        {
            We set the flag to "Greater".
            We put the pivot at the $c_1$.
            We go to the 1st line.
        }
    }
    
    "Less", then 
    {
        If $d_p = 1$ and the values of all the counters 
        on the left of $c_p$ are equal to 2 then 
        {
            We end the whole algorithm with the answer "no".
        }
        We increase $c_p$ by one ($d_p \coloneqq d_p + 1$) and
        we set the value of all counters on the left of $c_p$ to $d_p$.
        If $\chi^{orb}(*d_1d_2d_3\dots)=\frac{p}{q}$ then
        {
            We found an orbifold, we add it to a list 
            and increase the occurence counter by 1. 
            We set the flag to "Less".
            We put pivot at the $c_{p+1}$.
            We go to the line 1..
        }
        If $\chi^{orb}(*d_1d_2d_3\dots)>\frac{p}{q}$ then  
        {
            We set the flag to "Greater".
            We put the pivot at the $c_1$. 
            We go to the 1st line.
        } 
        If $\chi^{orb}(*d_1d_2d_3\dots)<\frac{p}{q}$ then
        {
            We set the flag to "Less".
            We put pivot at the $c_{p+1}$.
            We go to the 1st line.
        } 
    }
}
\end{lstlisting}

\section{Proof of the correctness of the algorithm}
Let us observe, that whole proof from the chapter \ref{} was independent from the choise of 
the starting configuration. As such, since algorithm from this chapter is the repeting iteration 
of the algorithm from chapter \ref{} and since \ref{}, 
above algorithm will hold all nesseserly traits. $_\square$

\section{Implementation}\label{implementation}
As an appendix in the separate document, there is a source of a program with implementation 
of this algorithm with optimisation described below.
%with full  
%enhancments described in this chapter. 
It is written in Rust. 
It can be also found on \smalltodoII{daÄ‡ ref do github} along with the \LaTeX\ source of 
this thesis.
%It is in the separate file, as it would take too much space in this 
%document and wouldn't be readable. 

\subsection{Optimisations}
Binary search

\subsection{Limitations}
i64

