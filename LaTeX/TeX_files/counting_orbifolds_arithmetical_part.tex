% mainfile: ../praca_magisterska_orbifoldy.tex
\chapter{Counting orbifolds -- arithmetical part}\label{Counting orbifolds -- arithmetical part}


%\section{Arithmetical part}

%We want to determine this $n$. If $n = 0$, then $\frac{p}{q}$ is not in $\sigma$. 
%If $n > 0$, then $$
%\subsection{Deciding number of occurences}
%Searching for all occurences 

%The difficulty here is to carefully step other an occurence. 

%Compared to the previous version, we also use an occurance counter, starting with it set to 0 
%and with the list of orbifolds, wich is empty at the start.

This will be an extention of the algorithm from \ref{}. 

\begin{lstlisting}[firstnumber=1,consecutivenumbers=true]
In the case, the $flag\_value$ is equal to: 
{
    "Greater", then
    {
        If $\chi^{orb}(*d_1\dots d_{p-1}\infty d_{p+1}\dots)=\frac{p}{q}$ then
        {
            We found an orbifold, we add it to a list 
            and increase the occurence counter by 1. 
            We set the flag to "Less".
            We put pivot to the $c_{p+1}$ counter.
            We go to the 1st line.
        } 
        If $\chi^{orb}(*d_1\dots d_{p-1}\infty d_{p+1}\dots)>\frac{p}{q}$ then
        {
            We set $d_p$ to $\infty$.
            We set the flag to "Greater".
            We put the pivot at the $c_{p+1}$.
            We go to the 1st line.
        }  
        If $\chi^{orb}(*d_1\dots d_{p-1}\infty d_{p+1}\dots)<\frac{p}{q}$ then
        {
            We set the flag to "Searching".
            We go to the 1st line.
        }  
    }
    
    "Searching", then
    {
        We search one by one 
        for the value $d_p'$ of the $c_p$ such that 
        $\chi^{orb}(*d_1\dots d_{p-1}d_p'd_{p+1}\dots)\leq\frac{p}{q}$ and 
        $\chi^{orb}(*d_1\dots d_{p-1}(d_p'-1)d_{p+1}\dots)>\frac{p}{q}$.
        if $\chi^{orb}(*d_1\dots d_{p-1}d_p'd_{p+1}\dots)=\frac{p}{q}$ then 
        {
            We found an orbifold, we add it to a list 
            and increase the occurence counter by 1. 
            We set flag to "Less".
            We go to the 1st line.
        }
        We set $d_p$ and values of all the counters 
        to the left of $c_p$ to the value $d_p'$.
        if $\chi^{orb}(*d_1d_2d_3\dots)=\frac{p}{q}$ then 
        {
            We found an orbifold, we add it to a list 
            and increase the occurence counter by 1. 
            We set the flag to "Less".
            We put the pivot at the $c_{p+1}$.
            We go to the 1st line.
        }
        If $\chi^{orb}(*d_1d_2d_3\dots)<\frac{p}{q}$ then 
        {
            We set the flag to "Less".
            We put the pivot at the $c_{p+1}$.
            We go to the 1st line.
        }
        If $\chi^{orb}(*d_1d_2d_3\dots)>\frac{p}{q}$ then 
        {
            We set the flag to "Greater".
            We put the pivot at the $c_1$.
            We go to the 1st line.
        }
    }
    
    "Less", then 
    {
        If $d_p = 1$ and the values of all the counters 
        on the left of $c_p$ are equal to 2 then 
        {
            We end the whole algorithm with the answer "no".
        }
        We increase $c_p$ by one ($d_p \coloneqq d_p + 1$) and
        we set the value of all counters on the left of $c_p$ to $d_p$.
        If $\chi^{orb}(*d_1d_2d_3\dots)=\frac{p}{q}$ then
        {
            We found an orbifold, we add it to a list 
            and increase the occurence counter by 1. 
            We set the flag to "Less".
            We put pivot at the $c_{p+1}$.
            We go to the line 1..
        }
        If $\chi^{orb}(*d_1d_2d_3\dots)>\frac{p}{q}$ then  
        {
            We set the flag to "Greater".
            We put the pivot at the $c_1$. 
            We go to the 1st line.
        } 
        If $\chi^{orb}(*d_1d_2d_3\dots)<\frac{p}{q}$ then
        {
            We set the flag to "Less".
            We put pivot at the $c_{p+1}$.
            We go to the 1st line.
        } 
    }
}
\end{lstlisting}

\section{Why this works}

\section{Implementation}\label{implementation}
As an appendix in the separate document, there is a source of a program with implementation 
of this algorithm 
with full  
enhancments described in this chapter. It is written in Rust. 
It can be also found on \smalltodoII{daÄ‡ ref do github} along with the \LaTeX\ source of 
this thesis.
%It is in the separate file, as it would take too much space in this 
%document and wouldn't be readable. 

\subsection{Optimisations}
Binary search

\subsection{Limitations}
i64

